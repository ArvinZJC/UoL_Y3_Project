'''
@Description: a compressed feature extractor
@Version: 1.2.1.20200411
@Author: Robin Nix and Jian Zhang
@Date: 2020-02-20 19:01:12
@Last Editors: Jichen Zhao
@LastEditTime: 2020-04-11 16:54:50
'''

from androguard.core.analysis import analysis
from androguard.core.bytecodes import apk, dvm
import numpy as np
import os
import pickle
import re
import sys

from logger import Logger
from path_loader import get_benign_apps_directory, get_compressed_features_directory, get_dictionary_path, get_malware_directory


max_calls = 50 # this value influences the input size in the parts related to CNN


def extract_compressed_features():
    '''
    Extract compressed features for apps in the specified dataset and pickle them.
    '''

    api_call_dictionary = pickle.load(open(get_dictionary_path(), 'rb'), encoding = 'latin1') # change the encoding if there is a UnicodeDecodeError

    directory_list = [get_benign_apps_directory(), get_malware_directory()]

    # here "i" represents the category ID (0 - benign apps, 1 - malware)
    for i in range(len(directory_list)):
        for path in os.listdir(directory_list[i]):
            try:
                x, recursion_error_count = get_compressed_feature_vector(os.path.join(directory_list[i], path), api_call_dictionary)

                data_point = {}
                data_point['x'] = x
                data_point['y'] = i
                
                feature_stream = open(os.path.join(get_compressed_features_directory, str(path) + '.save'), 'wb')
                pickle.dump(data_point, feature_stream, protocol = pickle.DEFAULT_PROTOCOL)
                feature_stream.close()

                if recursion_error_count > 0:
                    Logger(os.path.basename(__file__), sys._getframe().f_code.co_name).w('The number of recursion errors is ' + str(recursion_error_count) + '.') # initialise a logger, and add a message and info of an exception with the level WARNING
            except:
                Logger(os.path.basename(__file__), sys._getframe().f_code.co_name).e('Failed to extract a compressed feature. An exception occurred.') # initialise a logger, and add a message and info of an exception with the level ERROR


def get_compressed_feature_vector(path, api_call_dictionary):
    '''
    Get a compressed feature vector.

    Parameters
    ----------
    path : the path of the file to get a compressed feature vector
    
    api_call_dictionary : a dictionary of API calls
    
    Returns
    -------
    feature_vector : a compressed feature vector

    recursion_error_count : the number of recursion errors
    '''

    max_sequences = max_calls
    feature_vector = np.zeros((max_calls, max_sequences), dtype = int)

    call_count = 0
    sequence_count = 0

    if path.endswith('.apk'):
        app = apk.APK(path)
        app_dex = dvm.DalvikVMFormat(app.get_dex())
    else: 
        app_dex = dvm.DalvikVMFormat(open(path, 'rb').read())

    app_x = analysis.Analysis(app_dex)
    class_names = [classes.get_name() for classes in app_dex.get_classes()]
    recursion_error_count = 0

    for method in app_dex.get_methods():
        g = app_x.get_method(method)
    
        if method.get_code() == None:
            continue

        for i in g.get_basic_blocks().get():
            if i.childs != [] and sequence_count < max_sequences:
                call_count = 0
                
                for ins in i.get_instructions():
                    output = ins.get_output() # this is a string that contains methods, variables, or anything else
                    match = re.search(r'(L[^;]*;)->[^\(]*\([^\)]*\).*', output)
                    
                    if match and match.group(1) not in class_names and call_count < max_calls:
                        feature_vector[call_count, sequence_count] = api_call_dictionary[match.group()]
                        call_count += 1

                rand_child_selected = np.random.randint(len(i.childs))
                recursion_error_count = traverse_graph(i.childs[rand_child_selected][2], feature_vector, class_names, call_count, sequence_count, recursion_error_count, api_call_dictionary)
                
                sequence_count += 1

    return feature_vector, recursion_error_count


def traverse_graph(node,
    feature_vector,
    class_names,
    call_count,
    sequence_count,
    recursion_error_count,
    api_call_dictionary) -> int:
    '''
    Recursively run the analyser to track different possible execution paths of the code (each run with a different random choice at the
    branching points).

    Parameters
    ----------
    node : a branch

    feature_vector : a compressed feature vector

    class_names : class names of the file being processed

    call_count : the number of calls

    sequence_count : the number of sequences
    
    recursion_error_count : the number of recursion errors

    api_call_dictionary : a dictionary of API calls

    Returns
    -------
    recursion_error_count : the number of recursion errors
    '''

    for ins in node.get_instructions():
        output = ins.get_output()
        match = re.search(r'(L[^;]*;)->[^\(]*\([^\)]*\).*', output)

        if match and match.group(1) not in class_names and call_count < max_calls:
            feature_vector[call_count, sequence_count] = api_call_dictionary[match.group()]
            call_count += 1

    if node.childs != [] and call_count < max_calls:
        rand_child_selected = np.random.randint(len(node.childs))

        try:
            recursion_error_count = traverse_graph(node.childs[rand_child_selected][2], feature_vector, class_names, call_count, sequence_count, recursion_error_count, api_call_dictionary)
        # maximum recursion depth exceeded while calling a Python object
        except RecursionError:
            recursion_error_count += 1
    
    return recursion_error_count


# test purposes only
if __name__ == '__main__':
    extract_compressed_features()