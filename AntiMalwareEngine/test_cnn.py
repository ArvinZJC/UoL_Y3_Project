'''
@Description: testing a CNN
@Version: 1.2.4.20200422
@Author: Robin Nix and Jian Zhang
@Date: 2020-02-22 14:12:59
@Last Editors: Jichen Zhao
@LastEditTime: 2020-04-22 13:28:54
'''

import numpy as np
import os
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '1' # disable printing Tensorflow debugging messages with the level INFO
import tensorflow as tf

from cnn_ops import conv_net, get_one_hot_vector
from data_reader import load_test_data
from decompressor import decompress
from logger import Logger
from path_loader import get_cnn_trainer_saver_path


data_X, data_Y = load_test_data()

learning_rate = 0.00001
batch_size = 2
dimension_count = 86645 # train_data_X.max() + 10
input_size = 50
class_count = 2 

X = tf.placeholder(tf.float32, [None, input_size, dimension_count, 1])
Y = tf.placeholder(tf.float32, [None, class_count])

prediction = conv_net(X) # build the net
init_op = tf.global_variables_initializer() # intialise the variables to assign their default values
saver = tf.train.Saver()
log = Logger(os.path.basename(__file__), __name__) # initialise a logger

with tf.Session() as session:
    session.run(init_op)

    saver.restore(session, get_cnn_trainer_saver_path())

    batch_count = int(data_X.shape[0] / batch_size)
    TP, TN, FP, FN = 0, 0, 0, 0

    for step in range(batch_count):
        batch_x, batch_y = data_X[step * batch_size : (step + 1) * batch_size], data_Y[step * batch_size : (step + 1) * batch_size]

        batch_x = decompress(batch_x, dimension_count)
        batch_y = get_one_hot_vector(batch_size, batch_y)

        batch_result_list = session.run(tf.argmax(prediction, 1), feed_dict = {X: batch_x})
        batch_prediction_list = []

        for start_index in range(0, len(batch_result_list), input_size):
            batch_prediction_list.append(batch_result_list[start_index : start_index + input_size].max())
        
        # evaluate the model
        correct_answer_list = np.argmax(batch_y, 1)

        for i in range(len(batch_prediction_list)):
            if batch_prediction_list[i] == 1:
                if correct_answer_list[i] == 1:
                    TP += 1
                else:
                    FN += 1
            else:
                if correct_answer_list[i] == 1:
                    FP += 1
                else:
                    TN += 1

        correct_prediction = np.equal(batch_prediction_list, correct_answer_list)
        batch_accuracy = np.mean(correct_prediction)
        log.i('Step ' + str(step + 1) + ', batch accuracy: ' + '{:.3f}'.format(batch_accuracy))

    log.i('TP: ' + str(TP))
    log.i('TN: ' + str(TN))
    log.i('FP: ' + str(FP))
    log.i('FN: ' + str(FN))
    log.i('Accuracy: ' + '{:.3f}'.format((TP + TN) / (TP + TN + FP + FN)))
    log.i('Precision: ' + '{:.3f}'.format(TP / (TP + FP)))
    log.i('Recall: ' + '{:.3f}'.format(TP / (TP + FN)))