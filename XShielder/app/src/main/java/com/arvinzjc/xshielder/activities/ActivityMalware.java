/*
 * @Description: a class for the activity of the anti-malware shield
 * @Version: 1.4.1.20200415
 * @Author: Jichen Zhao
 * @Date: 2020-02-02 17:17:45
 * @Last Editors: Jichen Zhao
 * @LastEditTime : 2020-04-15 17:19:38
 */

package com.arvinzjc.xshielder.activities;

import android.app.ActivityManager;
import android.content.Context;
import android.content.Intent;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageManager;
import android.content.res.Configuration;
import android.graphics.Color;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.view.MenuItem;
import android.view.View;
import android.widget.Toast;

import androidx.annotation.NonNull;
import androidx.appcompat.app.AppCompatActivity;

import com.apkfuns.logutils.LogUtils;
import com.arvinzjc.xshielder.AppInitialiser;
import com.arvinzjc.xshielder.R;
import com.arvinzjc.xshielder.databinding.ActivityMalwareBinding;
import com.arvinzjc.xshielder.utils.AppUtils;
import com.arvinzjc.xshielder.utils.EngineUtils;
import com.arvinzjc.xshielder.utils.SystemUtils;
import com.mikepenz.iconics.IconicsColorInt;
import com.mikepenz.iconics.IconicsDrawable;
import com.mikepenz.iconics.IconicsSizeDp;
import com.mikepenz.iconics.typeface.library.ionicons.Ionicons;
import com.mikepenz.iconics.view.IconicsImageView;
import com.xuexiang.xui.utils.ViewUtils;
import com.xuexiang.xui.widget.dialog.materialdialog.DialogAction;
import com.xuexiang.xui.widget.dialog.materialdialog.MaterialDialog;
import com.xuexiang.xui.widget.grouplist.XUICommonListItemView;
import com.xuexiang.xui.widget.grouplist.XUIGroupListView;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Locale;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

public class ActivityMalware extends AppCompatActivity
{
    private static final String APK_FOLDER = "/apks/"; // refer to the folder containing APKs for scanning
    private static final String APK_EXTENSION = ".apk";
    private static final String APK_FEATURE_EXTENSION = ".save"; // the extension of the file containing APK features extracted
    private static final long SCAN_CACHE_LIFETIME = 7; // the scan cache (mainly refer to the APK files and SAVE files in the APK folder) has a lifetime of 7 days
    private static final int THREAD_TASK_TIMEOUT = 30; // the maximum time (unit: minute) to wait for thread tasks to complete execution
    private static final int MALWARE_UNINSTALLING_REQUEST = 0;  // the code of the request of uninstalling a malware
    private static final int ALL_MALWARE_UNINSTALLING_REQUEST = 1; // the code of the request of uninstalling all malware
    private static final int ALL_MALWARE_UNINSTALLING_FLAG_REQUEST = 2; // the code of the request of uninstalling all malware and updating results
    private static final int UNKNOWN_APP_UNINSTALLING_REQUEST = 3;  // the code of the request of uninstalling an unknown app
    private static final int BENIGN_APP_UNINSTALLING_REQUEST = 4;  // the code of the request of uninstalling a benign app
    private static final int LONG_SLEEP_DURATION = 5000; // the long sleep duration between each task of the integrated anti-malware engine
    private static final int SHORT_SLEEP_DURATION = 200; // the short sleep duration between each task of the integrated anti-malware engine

    /*
     * the number of basic tasks;
     * basic tasks include:
     *      1. getting the info list of non-system apps;
     *      2. updating the flag indicating if the scan cache is expired;
     *      3. checking Python startup;
     *      4. being ready for displaying results;
     */
    private static final int BASIC_TASK_COUNT = 4;

    private ActivityMalwareBinding mActivityMalwareBinding;
    private int mScanTaskCount, mCompletedScanTaskCount, mNonSystemAppCount, mMalwareCount, mUnknownAppCount, mBenignAppCount, mAnimationDuration;
    private double mAvailableMemory = 0.0d; // unit: GB
    private boolean mIsFirstScan = true;

    /*
     * the scan cache is expired and should be cleared when:
     *      1. the time difference between the present and the last modified time is longer than the scan cache lifetime;
     *      2. (if the previous not applicable) the number of APK files is not equal to the number of non-system apps;
     *      3. (if the previous not applicable) the APK arrays are different;
     *      4. (if the previous not applicable) the SAVE file corresponding to an APK file is missing (the API call dictionary file is not applicable because it is just used to generate those SAVE files);
     * the scan cache should also be cleared if the number of unknown apps is larger than 0 even though the value is "false"
     */
    private boolean mIsScanCacheExpired = true;

    private Configuration mConfiguration;
    private File mApkFolder; // a File object containing the directory of the folder containing APKs for scanning
    private AppInitialiser.FinalResults mFinalResult = null;
    private EngineUtils mEngineUtils;
    private PackageManager mPackageManager;
    private ApplicationInfo mUninstalledAppInfo;
    private ArrayList<ApplicationInfo> mNonSystemAppInfoList = new ArrayList<>(),
            mMalwareInfoList = new ArrayList<>(),
            mUnknownAppInfoList = new ArrayList<>(),
            mBenignAppInfoList = new ArrayList<>();
    private ArrayList<ApplicationInfo> mAppInQueueInfoList = new ArrayList<>(); // a list storing the info of non-system apps waiting for analysing
    private HashMap<String, Drawable> mNonSystemAppIconMap = new HashMap<>();
    private HashMap<String, String> mNonSystemAppNameMap = new HashMap<>();
    private ExecutorService mExecutorServiceScan;
    private XUIGroupListView.Section mGroupListViewSectionMalwareList, mGroupListViewSectionUnknownAppList, mGroupListViewSectionBenignAppList;
    private IconicsDrawable mDrawableUnknown, mDrawableBigUnknown;
    private MaterialDialog mDialogueScanStopConfirmation, mDialogueIssueDisregardConfirmation, mDialogueAllSystemApps;
    private Handler mHandlerMalware;

    @Override
    protected void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        LogUtils.i("Enter the activity of the anti-malware shield.");

        mConfiguration = getResources().getConfiguration();
        SystemUtils.changeStatusBarTheme(this, mConfiguration);
        SystemUtils.changeNavigationBarTheme(this, mConfiguration, getColor(R.color.app_themeColour), false);

        mActivityMalwareBinding = ActivityMalwareBinding.inflate(getLayoutInflater());
        setContentView(mActivityMalwareBinding.getRoot());
        setSupportActionBar(mActivityMalwareBinding.toolbarMalware);

        String apkFolderDirectory = AppUtils.getAppCacheDirectory(this) + APK_FOLDER; // the directory of the folder containing APKs for scanning

        mApkFolder = new File(apkFolderDirectory);
        mPackageManager = getPackageManager();
        mNonSystemAppInfoList = AppUtils.getNonSystemAppInfoList(this, mPackageManager);
        mNonSystemAppCount = mNonSystemAppInfoList.size();

        refreshScanTaskCount();

        mAnimationDuration = getResources().getInteger(android.R.integer.config_mediumAnimTime); // 400 milliseconds
        mExecutorServiceScan = Executors.newSingleThreadExecutor();
        mDrawableUnknown = new IconicsDrawable(this)
                .icon(Ionicons.Icon.ion_help)
                .color(new IconicsColorInt(getColor(R.color.colourWarning)))
                .size(new IconicsSizeDp(AppInitialiser.RESULT_ICON_SIZE));
        mDrawableBigUnknown = new IconicsDrawable(this)
                .icon(Ionicons.Icon.ion_ios_help)
                .color(new IconicsColorInt(getColor(R.color.colourWarning)))
                .size(new IconicsSizeDp(AppInitialiser.FINAL_RESULT_ICON_SIZE));
        mActivityMalwareBinding.roundButtonMalwareAction.setOnClickListener((View view) ->
        {
            if (mActivityMalwareBinding.roundButtonMalwareAction.getText().equals(getString(R.string.malware_roundButtonAction_fail)))
            {
                LogUtils.i("User chose to uninstall all malware.");

                int malwareListItemCount = mMalwareCount;

                for (int count = 0; count < malwareListItemCount; count++)
                    if (count == malwareListItemCount - 1)
                        startUninstalling(mMalwareInfoList.get(count), ALL_MALWARE_UNINSTALLING_FLAG_REQUEST);
                    else
                        startUninstalling(mMalwareInfoList.get(count), ALL_MALWARE_UNINSTALLING_REQUEST);
            }
            else
            {
                LogUtils.i("User chose to scan for malware again.");
                rescan();
            } // end if...else
        });
        mHandlerMalware = new Handler((Message message) ->
        {
            switch (message.what)
            {
                case AppInitialiser.PROGRESS_INCREMENT_FLAG:
                    mActivityMalwareBinding.circleProgressViewMalware.setProgress(++mCompletedScanTaskCount * 100f / mScanTaskCount);
                    if (mCompletedScanTaskCount == mScanTaskCount && mNonSystemAppCount > 0)
                        playAnimationAfterProgress();
                    return true;

                case AppInitialiser.PROGRESS_INITIALISATION_FLAG:
                    mActivityMalwareBinding.circleProgressViewMalware.setProgress(AppInitialiser.START_PROGRESS);
                    return true;

                case AppInitialiser.PROGRESS_ERROR_FLAG:
                    mCompletedScanTaskCount = mScanTaskCount;
                    mActivityMalwareBinding.circleProgressViewMalware.setProgress(AppInitialiser.END_PROGRESS);
                    playAnimationAfterProgress();
                    return true;

                default:
                    LogUtils.w("Received abnormal handler message flag (" + message.what + "). Some errors might occur.");
                    return false;
            } // end switch-case
        });

        // hide all widgets except the toolbar, the circle progress view, and the text view showing a notice for the scan
        mActivityMalwareBinding.imageViewMalware.setVisibility(View.INVISIBLE);
        mActivityMalwareBinding.textViewMalwareRationale.setVisibility(View.INVISIBLE);
        mActivityMalwareBinding.linearLayoutMalwareResults.setVisibility(View.INVISIBLE);

        (new Handler()).postDelayed(() -> mExecutorServiceScan.execute(() -> getMalwareResults(mIsFirstScan)), mAnimationDuration);
    } // end method onCreate

    /**
     * Dispatch incoming results to this activity.
     * @param requestCode the request code to identify who the results came from
     * @param resultCode the result code returned by the child activity
     * @param data an Intent which can return result data to the caller
     */
    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data)
    {
        super.onActivityResult(requestCode, resultCode, data);

        if (requestCode != MALWARE_UNINSTALLING_REQUEST
                && requestCode != ALL_MALWARE_UNINSTALLING_REQUEST
                && requestCode != ALL_MALWARE_UNINSTALLING_FLAG_REQUEST
                && requestCode != UNKNOWN_APP_UNINSTALLING_REQUEST
                && requestCode != BENIGN_APP_UNINSTALLING_REQUEST)
        {
            LogUtils.w("Received abnormal request code to identify who the results came from (" + requestCode + "). Some errors might occur.");
            return;
        } // end if

        if (requestCode == ALL_MALWARE_UNINSTALLING_FLAG_REQUEST)
        {
            ArrayList<ApplicationInfo> uninstalledMalwareInfoList = new ArrayList<>();

            // check what the user has selected for uninstalling an app
            for (ApplicationInfo malwareInfo : mMalwareInfoList)
            {
                if (AppUtils.isInstalled(this, mPackageManager, malwareInfo))
                    LogUtils.i("User chose not to uninstall an app (" + malwareInfo.packageName + ").");
                else
                {
                    LogUtils.i("User chose to uninstall an app (" + malwareInfo.packageName + ").");
                    mNonSystemAppInfoList.remove(malwareInfo);
                    mNonSystemAppIconMap.remove(malwareInfo.packageName);
                    mNonSystemAppNameMap.remove(malwareInfo.packageName);
                    uninstalledMalwareInfoList.add(malwareInfo);
                } // end if...else
            } // end for

            if (uninstalledMalwareInfoList.size() > 0)
            {
                mUninstalledAppInfo = null;
                mNonSystemAppCount = mNonSystemAppInfoList.size();
                mMalwareInfoList.removeAll(uninstalledMalwareInfoList);
                mMalwareCount = mMalwareInfoList.size();
                updateResults(requestCode);
            } // end if
        }
        else
        {
            if (AppUtils.isInstalled(this, mPackageManager, mUninstalledAppInfo))
                LogUtils.i("User chose not to uninstall an app (" + mUninstalledAppInfo.packageName + ").");
            else
            {
                LogUtils.i("User chose to uninstall an app (" + mUninstalledAppInfo.packageName + ").");
                updateResults(requestCode);
            } // end if...else
        } // end if...else
    } // end method onActivityResult

    /**
     * Confirm stopping checking Wi-Fi security when the back button is pressed and the scan is not completed.
     */
    @Override
    public void onBackPressed()
    {
        confirmBeforeLeaving();
    } // end method onBackPressed

    /**
     * Recreate the activity when the configuration of the dark theme is changed.
     * @param configuration the device configuration info
     */
    @Override
    public void onConfigurationChanged(@NonNull Configuration configuration)
    {
        super.onConfigurationChanged(configuration);
        recreate();
    } // end method onConfigurationChanged

    /**
     * Perform some necessary tasks when destroying this activity.
     */
    @Override
    public void onDestroy()
    {
        super.onDestroy();

        if (mDialogueScanStopConfirmation != null)
            mDialogueScanStopConfirmation.dismiss();

        if (mDialogueIssueDisregardConfirmation != null)
            mDialogueIssueDisregardConfirmation.dismiss();

        if (mDialogueAllSystemApps != null)
            mDialogueAllSystemApps.dismiss();

        if (mNonSystemAppCount > 0)
        {
            mNonSystemAppInfoList.clear();
            mNonSystemAppIconMap.clear();
            mNonSystemAppNameMap.clear();
        } // end if

        if (mMalwareCount > 0)
            mMalwareInfoList.clear();

        if (mUnknownAppCount > 0)
            mUnknownAppInfoList.clear();

        if (mBenignAppCount > 0)
            mBenignAppInfoList.clear();

        if (mAppInQueueInfoList.size() > 0)
            mAppInQueueInfoList.clear();

        if (mApkFolder.exists()
                && ((mIsScanCacheExpired && mCompletedScanTaskCount < mScanTaskCount)
                    || mUnknownAppCount > 0))
            AppUtils.clearApkFolder(mApkFolder);

        if (mFinalResult != AppInitialiser.FinalResults.PASS)
            SystemUtils.keepScreenOn(this, false);

        mExecutorServiceScan.shutdownNow();
        LogUtils.getLog2FileConfig().flushAsync(); // flush log cache to record logs in log files
    } // end method onDestroy

    /**
     * Respond to the selected event of the menu item on this activity's tool bar.
     * @param menuItem the menu item selected
     * @return  true to consume it here, or false to allow normal menu processing to proceed
     */
    @Override
    public boolean onOptionsItemSelected(@NonNull MenuItem menuItem)
    {
        if (menuItem.getItemId() == android.R.id.home)
        {
            confirmBeforeLeaving();
            return true;
        } // end if

        return super.onOptionsItemSelected(menuItem);
    } // end method onOptionsItemSelected

    // show a confirmation dialogue when necessary before finishing this activity
    private void confirmBeforeLeaving()
    {
        if (mCompletedScanTaskCount < mScanTaskCount)
            mDialogueScanStopConfirmation = new MaterialDialog.Builder(this)
                    .backgroundColor(getColor(R.color.card_backgroundColour))
                    .icon(new IconicsDrawable(this)
                            .icon(Ionicons.Icon.ion_information_circled)
                            .color(new IconicsColorInt(getColor(R.color.colourInfo)))
                            .size(new IconicsSizeDp(AppInitialiser.DIALOGUE_ICON_SIZE)))
                    .title(R.string.dialogueScanStopConfirmation_title)
                    .titleColor(getColor(R.color.primaryTextColour))
                    .content(R.string.malware_dialogueScanStopConfirmation_content)
                    .contentColor(getColor(R.color.contentTextColour))
                    .positiveText(R.string.dialogueScanStopConfirmation_positiveText)
                    .positiveColor(getColor(R.color.colourInfo))
                    .onPositive((MaterialDialog dialogue, DialogAction which) ->
                    {
                        // stop scanning for malware if the user clicks the confirmation button when the scan is not completed
                        if (mCompletedScanTaskCount < mScanTaskCount)
                        {
                            LogUtils.i("User chose to stop scanning for malware.");
                            finish();
                        } // end if
                    })
                    .negativeText(R.string.dialogue_defaultNegativeText)
                    .negativeColor(getColor(R.color.colourInfo))
                    .cancelable(false)
                    .show(); // show a confirmation dialogue asking whether to stop scanning for malware when the scan is not completed
        else
        {
            if (mFinalResult == AppInitialiser.FinalResults.FAIL)
                mDialogueIssueDisregardConfirmation = new MaterialDialog.Builder(this)
                        .backgroundColor(getColor(R.color.card_backgroundColour))
                        .icon(new IconicsDrawable(this)
                                .icon(Ionicons.Icon.ion_information_circled)
                                .color(new IconicsColorInt(getColor(R.color.colourInfo)))
                                .size(new IconicsSizeDp(AppInitialiser.DIALOGUE_ICON_SIZE)))
                        .title(R.string.dialogueIssueDisregardConfirmation_title)
                        .titleColor(getColor(R.color.primaryTextColour))
                        .content(R.string.malware_dialogueIssueDisregardConfirmation_content)
                        .contentColor(getColor(R.color.contentTextColour))
                        .positiveText(R.string.dialogueIssueDisregardConfirmation_positiveText)
                        .positiveColor(getColor(R.color.colourInfo))
                        .onPositive((MaterialDialog dialogue, DialogAction which) ->
                        {
                            LogUtils.i("User chose to disregard malware.");
                            finish();
                        })
                        .negativeText(R.string.dialogue_defaultNegativeText)
                        .negativeColor(getColor(R.color.colourInfo))
                        .cancelable(false)
                        .show(); // show a confirmation dialogue asking whether to disregard malware
            else
                finish();
        } // end if...else
    } // end method confirmBeforeLeaving

    // get malware scan results
    private void getMalwareResults(boolean isFirstScan)
    {
        runOnUiThread(() -> SystemUtils.keepScreenOn(this, true));

        mCompletedScanTaskCount = 0; // initialise the number of completed scan tasks

        if (!isFirstScan)
        {
            mNonSystemAppInfoList = AppUtils.getNonSystemAppInfoList(this, mPackageManager);
            mNonSystemAppCount = mNonSystemAppInfoList.size();
            mNonSystemAppIconMap.clear();
            mNonSystemAppNameMap.clear();

            if (mMalwareCount > 0)
                mMalwareInfoList.clear();

            if (mUnknownAppCount > 0)
                mUnknownAppInfoList.clear();

            if (mBenignAppCount > 0)
                mBenignAppInfoList.clear();

            if (mAppInQueueInfoList.size() > 0)
                mAppInQueueInfoList.clear();

            mMalwareCount = 0;
            mUnknownAppCount = 0;
            mBenignAppCount = 0;

            refreshScanTaskCount();

            mFinalResult = null;
            mUninstalledAppInfo = null;
            mIsScanCacheExpired = true;
        } // end if

        mHandlerMalware.sendEmptyMessage(AppInitialiser.PROGRESS_INCREMENT_FLAG); // complete getting the info list of non-system apps

        if (mNonSystemAppCount > 0)
        {
            String apkFolderDirectory = mApkFolder.getPath();

            if (mApkFolder.exists())
            {
                File[] scanCacheFiles = mApkFolder.listFiles();

                if (scanCacheFiles != null && scanCacheFiles.length > 0)
                {
                    Date scanCacheDate = new Date();
                    boolean isScanCacheDateUpdated = false;

                    for (File scanCacheFile : scanCacheFiles)
                        if (scanCacheFile.isFile())
                        {
                            scanCacheDate = new Date(scanCacheFile.lastModified());
                            isScanCacheDateUpdated = true;
                            break;
                        } // end if

                    if (isScanCacheDateUpdated)
                        if (TimeUnit.DAYS.convert(new Date().getTime() - scanCacheDate.getTime(), TimeUnit.MILLISECONDS) < SCAN_CACHE_LIFETIME)
                        {
                            int scanCacheApkCount = 0;
                            ArrayList<String> scanCacheApkNames = new ArrayList<>();

                            for(File scanCacheFile : scanCacheFiles)
                            {
                                String scanCacheFileName = scanCacheFile.getName();

                                if (scanCacheFileName.endsWith(APK_EXTENSION))
                                {
                                    scanCacheApkCount++;
                                    scanCacheApkNames.add(scanCacheFileName);
                                } // end if
                            } // end for

                            if (scanCacheApkCount == mNonSystemAppCount)
                            {
                                ArrayList<String> nonSystemAppApkNames = new ArrayList<>();

                                for (ApplicationInfo nonSystemAppInfo : mNonSystemAppInfoList)
                                    nonSystemAppApkNames.add(nonSystemAppInfo.packageName + APK_EXTENSION);

                                String[] scanCacheApkNameArray = scanCacheApkNames.toArray(new String[scanCacheApkCount]);
                                String[] nonSystemAppApkNameArray = nonSystemAppApkNames.toArray(new String[mNonSystemAppCount]);

                                Arrays.sort(scanCacheApkNameArray);
                                Arrays.sort(nonSystemAppApkNameArray);

                                if (Arrays.equals(scanCacheApkNameArray, nonSystemAppApkNameArray))
                                {
                                    mIsScanCacheExpired = false;

                                    for (String scanCacheApkName : scanCacheApkNameArray)
                                        if (!new File(apkFolderDirectory + "/" + scanCacheApkName + APK_FEATURE_EXTENSION).exists())
                                        {
                                            mIsScanCacheExpired = true;
                                            break;
                                        } // end if
                                } // end if
                            } // end if
                        } // end if
                } // end if
            } // end if

            mHandlerMalware.sendEmptyMessage(AppInitialiser.PROGRESS_INCREMENT_FLAG); // complete updating the flag indicating if the scan cache is expired

            mEngineUtils = new EngineUtils(this, apkFolderDirectory);
            mHandlerMalware.sendEmptyMessage(AppInitialiser.PROGRESS_INCREMENT_FLAG); // complete checking Python startup

            runOnUiThread(() ->
            {
                if (isFirstScan)
                {
                    XUIGroupListView.newSection(this).setDescription(getString(R.string.malware_appList_discription)).addTo(mActivityMalwareBinding.groupListViewMalwareResults);
                    XUIGroupListView.newSection(this).setDescription(" ").addTo(mActivityMalwareBinding.groupListViewMalwareResults); // this section is added to leave space between 2 sections
                } // end if

                initialiseMalwareList();
                initialiseUnknownAppList();
                initialiseBenignAppList();
            });

            if (mApkFolder.exists())
            {
                if (mIsScanCacheExpired)
                    AppUtils.clearApkFolder(mApkFolder);

                performScanTasks();
            }
            else
            {
                if (mApkFolder.mkdirs())
                {
                    LogUtils.i("Successfully create the folder under an app-specific cache directory for storing APKs for scanning.");
                    performScanTasks();
                }
                else
                {
                    LogUtils.w("Failed to create the folder under an app-specific cache directory for storing APKs for scanning. Some errors might occur.");

                    for (ApplicationInfo nonSystemAppInfo : mNonSystemAppInfoList)
                    {
                        mNonSystemAppIconMap.put(nonSystemAppInfo.packageName, nonSystemAppInfo.loadIcon(mPackageManager));
                        mNonSystemAppNameMap.put(nonSystemAppInfo.packageName, nonSystemAppInfo.loadLabel(mPackageManager).toString());
                    } // end for

                    mUnknownAppInfoList.addAll(mNonSystemAppInfoList);
                    mUnknownAppCount = mUnknownAppInfoList.size();
                    updateFinalResults();
                    runOnUiThread(this::updateUnknownAppList);
                    mHandlerMalware.sendEmptyMessage(AppInitialiser.PROGRESS_ERROR_FLAG);
                } // end if...else
            } // end if...else
        }
        /*
         * avoid sending the error flag to the handler, as the circle progress should not be faded out in this situation;
         * avoid sending increment flags to the handler to ensure that the APK folder can be cleared when the activity is destroyed
         */
        else
            runOnUiThread(() -> mDialogueAllSystemApps = new MaterialDialog.Builder(this)
                    .backgroundColor(getColor(R.color.card_backgroundColour))
                    .icon(new IconicsDrawable(this)
                            .icon(Ionicons.Icon.ion_information_circled)
                            .color(new IconicsColorInt(getColor(R.color.colourInfo)))
                            .size(new IconicsSizeDp(AppInitialiser.DIALOGUE_ICON_SIZE)))
                    .title(R.string.malware_dialogueAllSystemApps_title)
                    .titleColor(getColor(R.color.primaryTextColour))
                    .content(R.string.malware_dialogueAllSystemApps_content)
                    .contentColor(getColor(R.color.contentTextColour))
                    .positiveText(R.string.dialogue_defaultPositiveText)
                    .positiveColor(getColor(R.color.colourInfo))
                    .onPositive((MaterialDialog dialogue, DialogAction which) ->
                    {
                        LogUtils.i("Return to the specified activity because all installed apps except this app can be considered as secured system apps.");
                        finish();
                    })
                    .cancelable(false)
                    .show() // show a dialogue informing the lack of third-party apps to scan for malware
            );

        if (mFinalResult == AppInitialiser.FinalResults.PASS)
            runOnUiThread(() -> SystemUtils.keepScreenOn(this, false));
    } // end method getMalwareResults

    // initialise the section of the benign app list in the group list view
    private void initialiseBenignAppList()
    {
        if (mGroupListViewSectionBenignAppList != null)
            mGroupListViewSectionBenignAppList.removeFrom(mActivityMalwareBinding.groupListViewMalwareResults);

        mGroupListViewSectionBenignAppList = XUIGroupListView.newSection(this)
                .setSeparatorDrawableRes(R.drawable.list_item_background_selector,
                        R.drawable.list_item_background_selector,
                        R.drawable.list_item_background_selector,
                        R.drawable.list_item_background_selector)
                .setLeftIconSize(AppInitialiser.APP_LIST_ICON_SIZE, AppInitialiser.APP_LIST_ICON_SIZE);
    } // end method initialiseBenignAppList

    // initialise the section of the malware list in the group list view
    private void initialiseMalwareList()
    {
        if (mGroupListViewSectionMalwareList != null)
            mGroupListViewSectionMalwareList.removeFrom(mActivityMalwareBinding.groupListViewMalwareResults);

        mGroupListViewSectionMalwareList = XUIGroupListView.newSection(this)
                .setDescription(" ") // this description is set so as to leave space between 2 sections
                .setSeparatorDrawableRes(R.drawable.list_item_background_selector,
                        R.drawable.list_item_background_selector,
                        R.drawable.list_item_background_selector,
                        R.drawable.list_item_background_selector)
                .setLeftIconSize(AppInitialiser.APP_LIST_ICON_SIZE, AppInitialiser.APP_LIST_ICON_SIZE);
    } // end method initialiseMalwareList

    // initialise the section of the unknown app list in the group list view
    private void initialiseUnknownAppList()
    {
        if (mGroupListViewSectionUnknownAppList != null)
            mGroupListViewSectionUnknownAppList.removeFrom(mActivityMalwareBinding.groupListViewMalwareResults);

        mGroupListViewSectionUnknownAppList = XUIGroupListView.newSection(this)
                .setDescription(" ") // this description is set so as to leave space between 2 sections
                .setSeparatorDrawableRes(R.drawable.list_item_background_selector,
                        R.drawable.list_item_background_selector,
                        R.drawable.list_item_background_selector,
                        R.drawable.list_item_background_selector)
                .setLeftIconSize(AppInitialiser.APP_LIST_ICON_SIZE, AppInitialiser.APP_LIST_ICON_SIZE);
    } // end method initialiseUnknownAppList

    // perform scan tasks when the number of non-system apps is over 0 and it is ready to store APKs for scanning in the folder under an app-specific cache directory
    private void performScanTasks()
    {
        ExecutorService executorServiceParallelTasks = Executors.newFixedThreadPool(AppInitialiser.CPU_CORE_COUNT + 1 < mNonSystemAppCount ? AppInitialiser.CPU_CORE_COUNT : mNonSystemAppCount);

        for (ApplicationInfo nonSystemAppInfo : mNonSystemAppInfoList)
        {
            executorServiceParallelTasks.execute(() ->
            {
                if (mIsScanCacheExpired)
                {
                    File newApk = new File(mApkFolder.getPath() + "/" + nonSystemAppInfo.packageName + APK_EXTENSION); // a File object containing the absolute path of a new APK file of a specified non-system app

                    try
                    {
                        if (newApk.createNewFile())
                        {
                            AppUtils.copyApk(nonSystemAppInfo, newApk);
                            mAppInQueueInfoList.add(nonSystemAppInfo);
                        }
                        else
                        {
                            LogUtils.w("Failed to create a new APK file of a specified non-system app (" + nonSystemAppInfo.packageName + "). Some errors might occur.");
                            mUnknownAppInfoList.add(nonSystemAppInfo);
                        } // end if...else
                    }
                    catch (IOException e)
                    {
                        LogUtils.e("Failed to copy the data of the source APK file of a specified non-system app (" + nonSystemAppInfo.packageName + ") to a new APK file. An exception occurred (" + e.getMessage() + ").");
                        LogUtils.e(e);
                        mUnknownAppInfoList.add(nonSystemAppInfo);
                    } // end try...catch
                }
                else
                    mAppInQueueInfoList.add(nonSystemAppInfo);

                mNonSystemAppIconMap.put(nonSystemAppInfo.packageName, nonSystemAppInfo.loadIcon(mPackageManager));
                mNonSystemAppNameMap.put(nonSystemAppInfo.packageName, nonSystemAppInfo.loadLabel(mPackageManager).toString());
                mHandlerMalware.sendEmptyMessage(AppInitialiser.PROGRESS_INCREMENT_FLAG); // complete copying the data of the source APK file of a specified non-system app to a new APK file
            });
        } // end for

        try
        {
            executorServiceParallelTasks.shutdown();

            if (!executorServiceParallelTasks.awaitTermination(THREAD_TASK_TIMEOUT, TimeUnit.MINUTES))
                executorServiceParallelTasks.shutdownNow();
        }
        catch (InterruptedException e)
        {
            LogUtils.e("The scan thread has been interrupted. An exception occurred (" + e.getMessage() + ").");
            LogUtils.e(e);
            executorServiceParallelTasks.shutdownNow();
            return;
        } // end try...catch

        ActivityManager activityManager = (ActivityManager)this.getSystemService(Context.ACTIVITY_SERVICE);
        ActivityManager.MemoryInfo memoryInfo = new ActivityManager.MemoryInfo();

        if (activityManager != null)
        {
            activityManager.getMemoryInfo(memoryInfo);
            mAvailableMemory = (double)memoryInfo.availMem / (1024L * 1024L * 1024L);
        }
        else
        {
            LogUtils.w("Failed to get the amount of available memory. Some errors might occur.");
            mAvailableMemory = 0.0d;
        } // end if...else

        Thread threadEngineTasks = new Thread(() ->
        {
            if (mAvailableMemory > 4.0d)
            {
                try
                {
                    if (mIsScanCacheExpired)
                    {
                        int dictionary_length = mEngineUtils.generateDictionary();

                        if (dictionary_length == -1 || dictionary_length == 0)
                        {
                            LogUtils.w("Failed to generate a suitable API call dictionary (" + dictionary_length + " returned). Some errors might occur.");
                            mUnknownAppInfoList.addAll(mAppInQueueInfoList);
                            mAppInQueueInfoList.clear();
                        }
                        else
                        {
                            HashMap<String, String> problemMap = mEngineUtils.extractFeatures();

                            if (problemMap.size() > 0)
                                for (ApplicationInfo appInQueueInfo : mAppInQueueInfoList)
                                {
                                    String problem = problemMap.get(appInQueueInfo.packageName + APK_EXTENSION);

                                    if (problem != null && problem.startsWith("HasRecursionError"))
                                    {
                                        LogUtils.w("Failed to extract complete features of an app (" + appInQueueInfo.packageName + "). Some errors might occur (" + problem + ").");
                                        problemMap.remove(appInQueueInfo.packageName + APK_EXTENSION);
                                    } // end if
                                } // end for

                            // the size should not be stored in a variable, as the change of it needs considering here
                            if (problemMap.size() > 0)
                            {
                                LogUtils.w("Failed to extract features of specified apps. Some errors might occur (" + problemMap + ").");

                                if (problemMap.size() == mAppInQueueInfoList.size())
                                {
                                    mUnknownAppInfoList.addAll(mAppInQueueInfoList);
                                    mAppInQueueInfoList.clear();
                                }
                                else
                                {
                                    ArrayList<ApplicationInfo> tempList = new ArrayList<>(); // a list storing the application info which should be removed from the list storing the info of non-system apps waiting for analysing

                                    for (ApplicationInfo appInQueueInfo : mAppInQueueInfoList)
                                        if (problemMap.containsKey(appInQueueInfo.packageName + APK_EXTENSION))
                                        {
                                            mUnknownAppInfoList.add(appInQueueInfo);
                                            tempList.add(appInQueueInfo);
                                        } // end if

                                    mAppInQueueInfoList.removeAll(tempList);
                                } // end if...else
                            } // end if

                            // the size should not be stored in a variable, as the change of it needs considering here
                            if (mAppInQueueInfoList.size() > 0)
                                scanForMalware();
                        } // end if...else
                    }
                    else
                        scanForMalware();
                }
                catch (Exception e)
                {
                    LogUtils.e("Failed to finish executing the tasks of the integrated anti-malware engine. An exception occurred (" + e.getMessage() + ").");
                    LogUtils.e(e);
                    mUnknownAppInfoList.addAll(mAppInQueueInfoList);
                    mAppInQueueInfoList.clear();
                } // end try...catch
            }
            else
            {
                LogUtils.w("Failed to run the tasks of the integrated anti-malware engine. Insufficient available memory (approximately " + String.format(Locale.UK, "%.1f", mAvailableMemory) + "GB).");
                mUnknownAppInfoList.addAll(mAppInQueueInfoList);
                mAppInQueueInfoList.clear();
            } // end if...else
        }); // a thread for running the 3 tasks of the integrated anti-malware engine
        Thread threadEngineTasksProgressUpdater = new Thread(() ->
        {
            // "complete" the 3 tasks of the integrated anti-malware engine
            for (int count = 1; count <= mNonSystemAppCount * 3; count++)
            {
                mHandlerMalware.sendEmptyMessage(AppInitialiser.PROGRESS_INCREMENT_FLAG);

                try
                {
                    if (mAvailableMemory > 4.0d)
                    {
                        if (mIsScanCacheExpired)
                            Thread.sleep(LONG_SLEEP_DURATION);
                        else
                        {
                            if (count > mNonSystemAppCount * 2)
                                Thread.sleep(LONG_SLEEP_DURATION);
                            else
                                Thread.sleep(SHORT_SLEEP_DURATION);
                        } // end if...else
                    } // end if
                }
                catch (InterruptedException e)
                {
                    LogUtils.e("The progress updater thread has been interrupted. An exception occurred (" + e.getMessage() + ").");
                    LogUtils.e(e);
                    return;
                } // end try...catch
            } // end for
        }); // a thread for running a fake progress updater when the 3 tasks of the integrated anti-malware engine are running

        threadEngineTasks.start();
        threadEngineTasksProgressUpdater.start();

        try
        {
            threadEngineTasks.join();
            threadEngineTasksProgressUpdater.join();
        }
        catch (InterruptedException e)
        {
            LogUtils.e("The process of executing the tasks of the integrated anti-malware engine has been interrupted. An exception occurred (" + e.getMessage() + "). This might be caused by stop scanning for malware.");
            LogUtils.e(e);
            return;
        } // end try...catch

        if (mApkFolder.exists() && mUnknownAppCount > 0)
            AppUtils.clearApkFolder(mApkFolder);

        mMalwareCount = mMalwareInfoList.size();
        mUnknownAppCount = mUnknownAppInfoList.size();
        mBenignAppCount = mBenignAppInfoList.size();
        updateFinalResults();
        runOnUiThread(() ->
        {
            updateMalwareList();
            updateUnknownAppList();
            updateBenignAppList();
        });
        LogUtils.i("Successfully finish scanning for malware.");
        mHandlerMalware.sendEmptyMessage(AppInitialiser.PROGRESS_INCREMENT_FLAG); // ready for displaying results
    } // end method performScanTasks

    // play animation to hide the circle progress view as well as the text view showing a notice for the scan and to display malware scan results
    private void playAnimationAfterProgress()
    {
        ViewUtils.fadeOut(mActivityMalwareBinding.circleProgressViewMalware, mAnimationDuration, null);
        ViewUtils.fadeOut(mActivityMalwareBinding.textViewMalwareScanNotice, mAnimationDuration, null);
        (new Handler()).postDelayed(() ->
        {
            ViewUtils.fadeIn(mActivityMalwareBinding.imageViewMalware, mAnimationDuration, null);
            ViewUtils.fadeIn(mActivityMalwareBinding.textViewMalwareRationale, mAnimationDuration, null);
            ViewUtils.slideIn(mActivityMalwareBinding.linearLayoutMalwareResults, mAnimationDuration, null, ViewUtils.Direction.BOTTOM_TO_TOP);
            SystemUtils.changeNavigationBarTheme(this, mConfiguration, getColor(R.color.card_backgroundColour), false);
            mActivityMalwareBinding.roundButtonMalwareAction.setEnabled(true);
        }, mAnimationDuration / 2);
    } // end method playAnimationAfterProgress

    // refresh the number of scan tasks
    private void refreshScanTaskCount()
    {
        /*
         * task list:
         *      > basic tasks;
         *      > copying and storing the source APK data of the non-system apps (the number of tasks is equal to the number of non-system apps);
         *      > 3 tasks of the integrated anti-malware engine:
         *          - generating an API call dictionary (the number of tasks is equal to the number of non-system apps);
         *          - extracting features for apps (the number of tasks is equal to the number of non-system apps);
         *          - deciding if an app is benign or malicious (the number of tasks is equal to the number of non-system apps)
         */
        mScanTaskCount = BASIC_TASK_COUNT + mNonSystemAppCount + mNonSystemAppCount + mNonSystemAppCount + mNonSystemAppCount;
    } // end method refreshScanTaskCount

    // rescan for malware
    private void rescan()
    {
        mActivityMalwareBinding.roundButtonMalwareAction.setEnabled(false); // avoid abnormal progress values when the user clicks quickly
        mHandlerMalware.sendEmptyMessage(AppInitialiser.PROGRESS_INITIALISATION_FLAG);
        ViewUtils.fadeOut(mActivityMalwareBinding.imageViewMalware, mAnimationDuration, null);
        ViewUtils.fadeOut(mActivityMalwareBinding.textViewMalwareRationale, mAnimationDuration, null);
        ViewUtils.slideOut(mActivityMalwareBinding.linearLayoutMalwareResults, mAnimationDuration, null, ViewUtils.Direction.TOP_TO_BOTTOM);
        (new Handler()).postDelayed(() ->
        {
            SystemUtils.changeNavigationBarTheme(this, mConfiguration, getColor(R.color.app_themeColour), false);
            ViewUtils.fadeIn(mActivityMalwareBinding.circleProgressViewMalware, mAnimationDuration, null);
            ViewUtils.fadeIn(mActivityMalwareBinding.textViewMalwareScanNotice, mAnimationDuration, null);
        }, mAnimationDuration / 2);

        mIsFirstScan = false;

        (new Handler()).postDelayed(() -> mExecutorServiceScan.execute(() -> getMalwareResults(mIsFirstScan)), mAnimationDuration);
    } // end method rescan

    // use the integrated anti-malware engine to scan for malware
    private void scanForMalware()
    {
        HashMap<String, Integer> predictionMap = mEngineUtils.classifyApps();

        if (predictionMap.size() > 0)
        {
            for (ApplicationInfo appInQueueInfo : mAppInQueueInfoList)
            {
                Integer prediction = predictionMap.get(appInQueueInfo.packageName + APK_EXTENSION);

                if (prediction != null)
                {
                    if (prediction == 0)
                        mBenignAppInfoList.add(appInQueueInfo);
                    else
                        mMalwareInfoList.add(appInQueueInfo);
                }
                else
                {
                    LogUtils.w("Failed to classify a specified app (" + appInQueueInfo.packageName + "). Some errors might occur (No corresponding prediction).");
                    mUnknownAppInfoList.add(appInQueueInfo);
                } // end if...else
            } // end for
        }
        else
        {
            LogUtils.w("Failed to classify any app as a benign or malicious app. Some errors might occur.");
            mUnknownAppInfoList.addAll(mAppInQueueInfoList);
        } // end if...else

        mAppInQueueInfoList.clear();
    } // end method scanForMalware

    // start uninstalling a specified app (if installed) with a specified request code
    private void startUninstalling(@NonNull ApplicationInfo appInfo, int requestCode)
    {
        mUninstalledAppInfo = appInfo;

        if (AppUtils.isInstalled(this, mPackageManager, mUninstalledAppInfo))
        {
            Intent intentAppUninstalling = new Intent(Intent.ACTION_DELETE, Uri.parse("package:" + mUninstalledAppInfo.packageName));

            if (requestCode == ALL_MALWARE_UNINSTALLING_REQUEST)
                startActivity(intentAppUninstalling);
            else
                startActivityForResult(intentAppUninstalling, requestCode);

            LogUtils.i("User was asked to confirm to uninstall an app (" + mUninstalledAppInfo.packageName + ").");
        }
        else
        {
            LogUtils.w("Failed to find an app (" + mUninstalledAppInfo.packageName + "). It might have been uninstalled.");
            Toast.makeText(getApplicationContext(),
                    mNonSystemAppNameMap.get(mUninstalledAppInfo.packageName) + getString(R.string.malware_toastAppNotFound),
                    Toast.LENGTH_SHORT).show(); // the application context is required to avoid any abnormal toast styles
            updateResults(requestCode);
        } // end if...else
    } // end method startUninstalling

    // update malware scan results according to the request code when uninstalling an app or all malware
    private void updateResults(int requestCode)
    {
        if (mUninstalledAppInfo != null)
        {
            mNonSystemAppInfoList.remove(mUninstalledAppInfo);
            mNonSystemAppCount = mNonSystemAppInfoList.size();
            mNonSystemAppIconMap.remove(mUninstalledAppInfo.packageName);
            mNonSystemAppNameMap.remove(mUninstalledAppInfo.packageName);
        } // end if

        if (mNonSystemAppCount > 0)
        {
            ViewUtils.fadeOut(mActivityMalwareBinding.imageViewMalware, mAnimationDuration, null);
            ViewUtils.fadeOut(mActivityMalwareBinding.textViewMalwareRationale, mAnimationDuration, null);

            switch (requestCode)
            {
                case MALWARE_UNINSTALLING_REQUEST:
                case ALL_MALWARE_UNINSTALLING_FLAG_REQUEST:
                    if (mUninstalledAppInfo != null)
                    {
                        mMalwareInfoList.remove(mUninstalledAppInfo);
                        mMalwareCount = mMalwareInfoList.size();
                    } // end if
                    initialiseMalwareList();
                    updateMalwareList();
                    if (mUnknownAppCount > 0)
                    {
                        mGroupListViewSectionUnknownAppList.removeFrom(mActivityMalwareBinding.groupListViewMalwareResults);
                        mGroupListViewSectionUnknownAppList.setTitle(getString(R.string.malware_unknownAppList_title) + mUnknownAppCount + "/" + mNonSystemAppCount + ")");
                        mGroupListViewSectionUnknownAppList.addTo(mActivityMalwareBinding.groupListViewMalwareResults);
                    } // end if
                    if (mBenignAppCount > 0)
                    {
                        mGroupListViewSectionBenignAppList.removeFrom(mActivityMalwareBinding.groupListViewMalwareResults);
                        mGroupListViewSectionBenignAppList.setTitle(getString(R.string.malware_benignAppList_title) + mBenignAppCount + "/" + mNonSystemAppCount + ")");
                        mGroupListViewSectionBenignAppList.addTo(mActivityMalwareBinding.groupListViewMalwareResults);
                    } // end if
                    updateFinalResults();
                    break;

                case UNKNOWN_APP_UNINSTALLING_REQUEST:
                    if (mUninstalledAppInfo != null)
                    {
                        mUnknownAppInfoList.remove(mUninstalledAppInfo);
                        mUnknownAppCount = mUnknownAppInfoList.size();
                    } // end if
                    if (mMalwareCount > 0)
                    {
                        mGroupListViewSectionMalwareList.removeFrom(mActivityMalwareBinding.groupListViewMalwareResults);
                        mGroupListViewSectionMalwareList.setTitle(getString(R.string.malware_malwareList_title) + mMalwareCount + "/" + mNonSystemAppCount + ")");
                        mGroupListViewSectionMalwareList.addTo(mActivityMalwareBinding.groupListViewMalwareResults);
                    } // end if
                    initialiseUnknownAppList();
                    updateUnknownAppList();
                    if (mBenignAppCount > 0)
                    {
                        mGroupListViewSectionBenignAppList.removeFrom(mActivityMalwareBinding.groupListViewMalwareResults);
                        mGroupListViewSectionBenignAppList.setTitle(getString(R.string.malware_benignAppList_title) + mBenignAppCount + "/" + mNonSystemAppCount + ")");
                        mGroupListViewSectionBenignAppList.addTo(mActivityMalwareBinding.groupListViewMalwareResults);
                    } // end if
                    updateFinalResults();
                    break;

                case BENIGN_APP_UNINSTALLING_REQUEST:
                    if (mUninstalledAppInfo != null)
                    {
                        mBenignAppInfoList.remove(mUninstalledAppInfo);
                        mBenignAppCount = mBenignAppInfoList.size();
                    } // end if
                    if (mMalwareCount > 0)
                    {
                        mGroupListViewSectionMalwareList.removeFrom(mActivityMalwareBinding.groupListViewMalwareResults);
                        mGroupListViewSectionMalwareList.setTitle(getString(R.string.malware_malwareList_title) + mMalwareCount + "/" + mNonSystemAppCount + ")");
                        mGroupListViewSectionMalwareList.addTo(mActivityMalwareBinding.groupListViewMalwareResults);
                    } // end if
                    if (mUnknownAppCount > 0)
                    {
                        mGroupListViewSectionUnknownAppList.removeFrom(mActivityMalwareBinding.groupListViewMalwareResults);
                        mGroupListViewSectionUnknownAppList.setTitle(getString(R.string.malware_unknownAppList_title) + mUnknownAppCount + "/" + mNonSystemAppCount + ")");
                        mGroupListViewSectionUnknownAppList.addTo(mActivityMalwareBinding.groupListViewMalwareResults);
                    } // end if
                    initialiseBenignAppList();
                    updateBenignAppList();
                    updateFinalResults();
            } // end switch...case

            ViewUtils.fadeIn(mActivityMalwareBinding.imageViewMalware, mAnimationDuration, null);
            ViewUtils.fadeIn(mActivityMalwareBinding.textViewMalwareRationale, mAnimationDuration, null);

            if (mFinalResult == AppInitialiser.FinalResults.PASS)
                SystemUtils.keepScreenOn(this, false);
        }
        else
            rescan();
    } // end method updateResults

    // update the section of the benign app list in the group list view
    private void updateBenignAppList()
    {
        if (mBenignAppCount > 0)
        {
            Collections.sort(mBenignAppInfoList, new ApplicationInfo.DisplayNameComparator(mPackageManager));

            for (ApplicationInfo benignAppInfo : mBenignAppInfoList)
            {
                XUICommonListItemView commonListItemViewBenignApp = mActivityMalwareBinding.groupListViewMalwareResults.createItemView(
                        mNonSystemAppIconMap.get(benignAppInfo.packageName),
                        mNonSystemAppNameMap.get(benignAppInfo.packageName),
                        null,
                        XUICommonListItemView.HORIZONTAL,
                        XUICommonListItemView.ACCESSORY_TYPE_CUSTOM);
                IconicsImageView imageViewBenignApp = new IconicsImageView(this);
                View.OnClickListener onClickListenerApp = view -> startUninstalling(benignAppInfo, BENIGN_APP_UNINSTALLING_REQUEST);
                imageViewBenignApp.setIcon(new IconicsDrawable(this)
                        .icon(Ionicons.Icon.ion_checkmark_round)
                        .color(new IconicsColorInt(getColor(R.color.colourPass)))
                        .size(new IconicsSizeDp(AppInitialiser.RESULT_ICON_SIZE)));
                commonListItemViewBenignApp.addAccessoryCustomView(imageViewBenignApp);
                mGroupListViewSectionBenignAppList.addItemView(commonListItemViewBenignApp, onClickListenerApp);
            } // end for

            mGroupListViewSectionBenignAppList.setTitle(getString(R.string.malware_benignAppList_title) + mBenignAppCount + "/" + mNonSystemAppCount + ")");
            mGroupListViewSectionBenignAppList.addTo(mActivityMalwareBinding.groupListViewMalwareResults);
        } // end if
    } // end method updateBenignAppList

    /*
     * update the variable and views related to the final results;
     * avoid calling this method on the UI thread (runOnUiThread()) from a different thread to ensure that the variable can be updated in time
     */
    private void updateFinalResults()
    {
        if (mMalwareCount > 0)
        {
            mFinalResult = AppInitialiser.FinalResults.FAIL;

            runOnUiThread(() ->
            {
                mActivityMalwareBinding.imageViewMalware.setIcon(new IconicsDrawable(this)
                        .icon(Ionicons.Icon.ion_android_alert)
                        .color(new IconicsColorInt(Color.RED))
                        .size(new IconicsSizeDp(AppInitialiser.FINAL_RESULT_ICON_SIZE)));
                mActivityMalwareBinding.textViewMalwareRationale.setText(R.string.malware_textViewRationale_fail);
                mActivityMalwareBinding.roundButtonMalwareAction.setText(R.string.malware_roundButtonAction_fail);
            });
        }
        else if (mUnknownAppCount > 0)
        {
            mFinalResult = AppInitialiser.FinalResults.UNKNOWN;

            runOnUiThread(() ->
            {
                mActivityMalwareBinding.imageViewMalware.setIcon(mDrawableBigUnknown);
                mActivityMalwareBinding.textViewMalwareRationale.setText(R.string.textViewRationale_unknown_appError);
                mActivityMalwareBinding.roundButtonMalwareAction.setText(R.string.roundButtonAction_unknown);
            });
        }
        else
        {
            mFinalResult = AppInitialiser.FinalResults.PASS;

            runOnUiThread(() ->
            {
                mActivityMalwareBinding.imageViewMalware.setIcon(new IconicsDrawable(this)
                        .icon(Ionicons.Icon.ion_checkmark_circled)
                        .color(new IconicsColorInt(getColor(R.color.colourPass)))
                        .size(new IconicsSizeDp(AppInitialiser.FINAL_RESULT_ICON_SIZE)));
                mActivityMalwareBinding.textViewMalwareRationale.setText(R.string.textViewRationale_pass);
                mActivityMalwareBinding.roundButtonMalwareAction.setText(R.string.roundButtonAction_normal);
            });
        } // end nested if...else
    } // end method updateFinalResults

    // update the section of the malware list in the group list view
    private void updateMalwareList()
    {
        if (mMalwareCount > 0)
        {
            Collections.sort(mMalwareInfoList, new ApplicationInfo.DisplayNameComparator(mPackageManager));

            for (ApplicationInfo malwareInfo : mMalwareInfoList)
            {
                XUICommonListItemView commonListItemViewMalwareListItem = mActivityMalwareBinding.groupListViewMalwareResults.createItemView(
                        mNonSystemAppIconMap.get(malwareInfo.packageName),
                        mNonSystemAppNameMap.get(malwareInfo.packageName),
                        null,
                        XUICommonListItemView.HORIZONTAL,
                        XUICommonListItemView.ACCESSORY_TYPE_CUSTOM);
                IconicsImageView imageViewMalwareListItem = new IconicsImageView(this);
                View.OnClickListener onClickListenerApp = view -> startUninstalling(malwareInfo, MALWARE_UNINSTALLING_REQUEST);
                imageViewMalwareListItem.setIcon(new IconicsDrawable(this)
                        .icon(Ionicons.Icon.ion_alert)
                        .color(new IconicsColorInt(Color.RED))
                        .size(new IconicsSizeDp(AppInitialiser.RESULT_ICON_SIZE)));
                commonListItemViewMalwareListItem.addAccessoryCustomView(imageViewMalwareListItem);
                mGroupListViewSectionMalwareList.addItemView(commonListItemViewMalwareListItem, onClickListenerApp);
            } // end for

            mGroupListViewSectionMalwareList.setTitle(getString(R.string.malware_malwareList_title) + mMalwareCount + "/" + mNonSystemAppCount + ")");
            mGroupListViewSectionMalwareList.addTo(mActivityMalwareBinding.groupListViewMalwareResults);
        } // end if
    } // end method updateMalwareList

    // update the section of the unknown app list in the group list view
    private void updateUnknownAppList()
    {
        if (mUnknownAppCount > 0)
        {
            Collections.sort(mUnknownAppInfoList, new ApplicationInfo.DisplayNameComparator(mPackageManager));

            for (ApplicationInfo unknownAppInfo : mUnknownAppInfoList)
            {
                XUICommonListItemView commonListItemViewUnknownApp = mActivityMalwareBinding.groupListViewMalwareResults.createItemView(
                        mNonSystemAppIconMap.get(unknownAppInfo.packageName),
                        mNonSystemAppNameMap.get(unknownAppInfo.packageName),
                        null,
                        XUICommonListItemView.HORIZONTAL,
                        XUICommonListItemView.ACCESSORY_TYPE_CUSTOM);
                IconicsImageView imageViewUnknownApp = new IconicsImageView(this);
                View.OnClickListener onClickListenerApp = view -> startUninstalling(unknownAppInfo, UNKNOWN_APP_UNINSTALLING_REQUEST);
                imageViewUnknownApp.setIcon(mDrawableUnknown);
                commonListItemViewUnknownApp.addAccessoryCustomView(imageViewUnknownApp);
                mGroupListViewSectionUnknownAppList.addItemView(commonListItemViewUnknownApp, onClickListenerApp);
            } // end for

            mGroupListViewSectionUnknownAppList.setTitle(getString(R.string.malware_unknownAppList_title) + mUnknownAppCount + "/" + mNonSystemAppCount + ")");
            mGroupListViewSectionUnknownAppList.addTo(mActivityMalwareBinding.groupListViewMalwareResults);
        } // end if
    } // end method updateUnknownAppList
} // end class ActivityMalware